// Code generated by MockGen. DO NOT EDIT.
// Source: internal/store/repository.go
//
// Generated by this command:
//
//	mockgen -source=internal/store/repository.go -destination=internal/store/mocks/mock_repository.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	model "github.com/emperorhan/multichain-indexer/internal/domain/model"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockTxBeginner is a mock of TxBeginner interface.
type MockTxBeginner struct {
	ctrl     *gomock.Controller
	recorder *MockTxBeginnerMockRecorder
	isgomock struct{}
}

// MockTxBeginnerMockRecorder is the mock recorder for MockTxBeginner.
type MockTxBeginnerMockRecorder struct {
	mock *MockTxBeginner
}

// NewMockTxBeginner creates a new mock instance.
func NewMockTxBeginner(ctrl *gomock.Controller) *MockTxBeginner {
	mock := &MockTxBeginner{ctrl: ctrl}
	mock.recorder = &MockTxBeginnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxBeginner) EXPECT() *MockTxBeginnerMockRecorder {
	return m.recorder
}

// BeginTx mocks base method.
func (m *MockTxBeginner) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
	ret0, _ := ret[0].(*sql.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockTxBeginnerMockRecorder) BeginTx(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockTxBeginner)(nil).BeginTx), ctx, opts)
}

// MockWatchedAddressRepository is a mock of WatchedAddressRepository interface.
type MockWatchedAddressRepository struct {
	ctrl     *gomock.Controller
	recorder *MockWatchedAddressRepositoryMockRecorder
	isgomock struct{}
}

// MockWatchedAddressRepositoryMockRecorder is the mock recorder for MockWatchedAddressRepository.
type MockWatchedAddressRepositoryMockRecorder struct {
	mock *MockWatchedAddressRepository
}

// NewMockWatchedAddressRepository creates a new mock instance.
func NewMockWatchedAddressRepository(ctrl *gomock.Controller) *MockWatchedAddressRepository {
	mock := &MockWatchedAddressRepository{ctrl: ctrl}
	mock.recorder = &MockWatchedAddressRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWatchedAddressRepository) EXPECT() *MockWatchedAddressRepositoryMockRecorder {
	return m.recorder
}

// FindByAddress mocks base method.
func (m *MockWatchedAddressRepository) FindByAddress(ctx context.Context, chain model.Chain, network model.Network, address string) (*model.WatchedAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByAddress", ctx, chain, network, address)
	ret0, _ := ret[0].(*model.WatchedAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByAddress indicates an expected call of FindByAddress.
func (mr *MockWatchedAddressRepositoryMockRecorder) FindByAddress(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByAddress", reflect.TypeOf((*MockWatchedAddressRepository)(nil).FindByAddress), ctx, chain, network, address)
}

// GetActive mocks base method.
func (m *MockWatchedAddressRepository) GetActive(ctx context.Context, chain model.Chain, network model.Network) ([]model.WatchedAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetActive", ctx, chain, network)
	ret0, _ := ret[0].([]model.WatchedAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActive indicates an expected call of GetActive.
func (mr *MockWatchedAddressRepositoryMockRecorder) GetActive(ctx, chain, network any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActive", reflect.TypeOf((*MockWatchedAddressRepository)(nil).GetActive), ctx, chain, network)
}

// Upsert mocks base method.
func (m *MockWatchedAddressRepository) Upsert(ctx context.Context, addr *model.WatchedAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, addr)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockWatchedAddressRepositoryMockRecorder) Upsert(ctx, addr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockWatchedAddressRepository)(nil).Upsert), ctx, addr)
}

// MockCursorRepository is a mock of CursorRepository interface.
type MockCursorRepository struct {
	ctrl     *gomock.Controller
	recorder *MockCursorRepositoryMockRecorder
	isgomock struct{}
}

// MockCursorRepositoryMockRecorder is the mock recorder for MockCursorRepository.
type MockCursorRepositoryMockRecorder struct {
	mock *MockCursorRepository
}

// NewMockCursorRepository creates a new mock instance.
func NewMockCursorRepository(ctrl *gomock.Controller) *MockCursorRepository {
	mock := &MockCursorRepository{ctrl: ctrl}
	mock.recorder = &MockCursorRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCursorRepository) EXPECT() *MockCursorRepositoryMockRecorder {
	return m.recorder
}

// EnsureExists mocks base method.
func (m *MockCursorRepository) EnsureExists(ctx context.Context, chain model.Chain, network model.Network, address string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureExists", ctx, chain, network, address)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureExists indicates an expected call of EnsureExists.
func (mr *MockCursorRepositoryMockRecorder) EnsureExists(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureExists", reflect.TypeOf((*MockCursorRepository)(nil).EnsureExists), ctx, chain, network, address)
}

// Get mocks base method.
func (m *MockCursorRepository) Get(ctx context.Context, chain model.Chain, network model.Network, address string) (*model.AddressCursor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, chain, network, address)
	ret0, _ := ret[0].(*model.AddressCursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCursorRepositoryMockRecorder) Get(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCursorRepository)(nil).Get), ctx, chain, network, address)
}

// UpsertTx mocks base method.
func (m *MockCursorRepository) UpsertTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, address string, cursorValue *string, cursorSequence, itemsProcessed int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockCursorRepositoryMockRecorder) UpsertTx(ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockCursorRepository)(nil).UpsertTx), ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed)
}

// MockTransactionRepository is a mock of TransactionRepository interface.
type MockTransactionRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionRepositoryMockRecorder
	isgomock struct{}
}

// MockTransactionRepositoryMockRecorder is the mock recorder for MockTransactionRepository.
type MockTransactionRepositoryMockRecorder struct {
	mock *MockTransactionRepository
}

// NewMockTransactionRepository creates a new mock instance.
func NewMockTransactionRepository(ctrl *gomock.Controller) *MockTransactionRepository {
	mock := &MockTransactionRepository{ctrl: ctrl}
	mock.recorder = &MockTransactionRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionRepository) EXPECT() *MockTransactionRepositoryMockRecorder {
	return m.recorder
}

// UpsertTx mocks base method.
func (m *MockTransactionRepository) UpsertTx(ctx context.Context, tx *sql.Tx, t *model.Transaction) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, t)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockTransactionRepositoryMockRecorder) UpsertTx(ctx, tx, t any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockTransactionRepository)(nil).UpsertTx), ctx, tx, t)
}

// MockBalanceEventRepository is a mock of BalanceEventRepository interface.
type MockBalanceEventRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBalanceEventRepositoryMockRecorder
	isgomock struct{}
}

// MockBalanceEventRepositoryMockRecorder is the mock recorder for MockBalanceEventRepository.
type MockBalanceEventRepositoryMockRecorder struct {
	mock *MockBalanceEventRepository
}

// NewMockBalanceEventRepository creates a new mock instance.
func NewMockBalanceEventRepository(ctrl *gomock.Controller) *MockBalanceEventRepository {
	mock := &MockBalanceEventRepository{ctrl: ctrl}
	mock.recorder = &MockBalanceEventRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceEventRepository) EXPECT() *MockBalanceEventRepositoryMockRecorder {
	return m.recorder
}

// UpsertTx mocks base method.
func (m *MockBalanceEventRepository) UpsertTx(ctx context.Context, tx *sql.Tx, be *model.BalanceEvent) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, be)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockBalanceEventRepositoryMockRecorder) UpsertTx(ctx, tx, be any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockBalanceEventRepository)(nil).UpsertTx), ctx, tx, be)
}

// MockBalanceRepository is a mock of BalanceRepository interface.
type MockBalanceRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBalanceRepositoryMockRecorder
	isgomock struct{}
}

// MockBalanceRepositoryMockRecorder is the mock recorder for MockBalanceRepository.
type MockBalanceRepositoryMockRecorder struct {
	mock *MockBalanceRepository
}

// NewMockBalanceRepository creates a new mock instance.
func NewMockBalanceRepository(ctrl *gomock.Controller) *MockBalanceRepository {
	mock := &MockBalanceRepository{ctrl: ctrl}
	mock.recorder = &MockBalanceRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceRepository) EXPECT() *MockBalanceRepositoryMockRecorder {
	return m.recorder
}

// AdjustBalanceTx mocks base method.
func (m *MockBalanceRepository) AdjustBalanceTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, address string, tokenID uuid.UUID, walletID, orgID *string, delta string, cursor int64, txHash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AdjustBalanceTx", ctx, tx, chain, network, address, tokenID, walletID, orgID, delta, cursor, txHash)
	ret0, _ := ret[0].(error)
	return ret0
}

// AdjustBalanceTx indicates an expected call of AdjustBalanceTx.
func (mr *MockBalanceRepositoryMockRecorder) AdjustBalanceTx(ctx, tx, chain, network, address, tokenID, walletID, orgID, delta, cursor, txHash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdjustBalanceTx", reflect.TypeOf((*MockBalanceRepository)(nil).AdjustBalanceTx), ctx, tx, chain, network, address, tokenID, walletID, orgID, delta, cursor, txHash)
}

// GetByAddress mocks base method.
func (m *MockBalanceRepository) GetByAddress(ctx context.Context, chain model.Chain, network model.Network, address string) ([]model.Balance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByAddress", ctx, chain, network, address)
	ret0, _ := ret[0].([]model.Balance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByAddress indicates an expected call of GetByAddress.
func (mr *MockBalanceRepositoryMockRecorder) GetByAddress(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByAddress", reflect.TypeOf((*MockBalanceRepository)(nil).GetByAddress), ctx, chain, network, address)
}

// MockTokenRepository is a mock of TokenRepository interface.
type MockTokenRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTokenRepositoryMockRecorder
	isgomock struct{}
}

// MockTokenRepositoryMockRecorder is the mock recorder for MockTokenRepository.
type MockTokenRepositoryMockRecorder struct {
	mock *MockTokenRepository
}

// NewMockTokenRepository creates a new mock instance.
func NewMockTokenRepository(ctrl *gomock.Controller) *MockTokenRepository {
	mock := &MockTokenRepository{ctrl: ctrl}
	mock.recorder = &MockTokenRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenRepository) EXPECT() *MockTokenRepositoryMockRecorder {
	return m.recorder
}

// FindByContractAddress mocks base method.
func (m *MockTokenRepository) FindByContractAddress(ctx context.Context, chain model.Chain, network model.Network, contractAddress string) (*model.Token, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByContractAddress", ctx, chain, network, contractAddress)
	ret0, _ := ret[0].(*model.Token)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByContractAddress indicates an expected call of FindByContractAddress.
func (mr *MockTokenRepositoryMockRecorder) FindByContractAddress(ctx, chain, network, contractAddress any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByContractAddress", reflect.TypeOf((*MockTokenRepository)(nil).FindByContractAddress), ctx, chain, network, contractAddress)
}

// UpsertTx mocks base method.
func (m *MockTokenRepository) UpsertTx(ctx context.Context, tx *sql.Tx, t *model.Token) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, t)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockTokenRepositoryMockRecorder) UpsertTx(ctx, tx, t any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockTokenRepository)(nil).UpsertTx), ctx, tx, t)
}

// MockIndexerConfigRepository is a mock of IndexerConfigRepository interface.
type MockIndexerConfigRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIndexerConfigRepositoryMockRecorder
	isgomock struct{}
}

// MockIndexerConfigRepositoryMockRecorder is the mock recorder for MockIndexerConfigRepository.
type MockIndexerConfigRepositoryMockRecorder struct {
	mock *MockIndexerConfigRepository
}

// NewMockIndexerConfigRepository creates a new mock instance.
func NewMockIndexerConfigRepository(ctrl *gomock.Controller) *MockIndexerConfigRepository {
	mock := &MockIndexerConfigRepository{ctrl: ctrl}
	mock.recorder = &MockIndexerConfigRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexerConfigRepository) EXPECT() *MockIndexerConfigRepositoryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockIndexerConfigRepository) Get(ctx context.Context, chain model.Chain, network model.Network) (*model.IndexerConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, chain, network)
	ret0, _ := ret[0].(*model.IndexerConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockIndexerConfigRepositoryMockRecorder) Get(ctx, chain, network any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIndexerConfigRepository)(nil).Get), ctx, chain, network)
}

// UpdateWatermarkTx mocks base method.
func (m *MockIndexerConfigRepository) UpdateWatermarkTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, ingestedSequence int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWatermarkTx", ctx, tx, chain, network, ingestedSequence)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWatermarkTx indicates an expected call of UpdateWatermarkTx.
func (mr *MockIndexerConfigRepositoryMockRecorder) UpdateWatermarkTx(ctx, tx, chain, network, ingestedSequence any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWatermarkTx", reflect.TypeOf((*MockIndexerConfigRepository)(nil).UpdateWatermarkTx), ctx, tx, chain, network, ingestedSequence)
}

// Upsert mocks base method.
func (m *MockIndexerConfigRepository) Upsert(ctx context.Context, c *model.IndexerConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, c)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockIndexerConfigRepositoryMockRecorder) Upsert(ctx, c any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockIndexerConfigRepository)(nil).Upsert), ctx, c)
}
