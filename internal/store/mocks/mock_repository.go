// Code generated by MockGen. DO NOT EDIT.
// Source: internal/store/repository.go
//
// Generated by this command:
//
//	mockgen -source=internal/store/repository.go -destination=internal/store/mocks/mock_repository.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	model "github.com/emperorhan/multichain-indexer/internal/domain/model"
	store "github.com/emperorhan/multichain-indexer/internal/store"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockTxBeginner is a mock of TxBeginner interface.
type MockTxBeginner struct {
	ctrl     *gomock.Controller
	recorder *MockTxBeginnerMockRecorder
	isgomock struct{}
}

// MockTxBeginnerMockRecorder is the mock recorder for MockTxBeginner.
type MockTxBeginnerMockRecorder struct {
	mock *MockTxBeginner
}

// NewMockTxBeginner creates a new mock instance.
func NewMockTxBeginner(ctrl *gomock.Controller) *MockTxBeginner {
	mock := &MockTxBeginner{ctrl: ctrl}
	mock.recorder = &MockTxBeginnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxBeginner) EXPECT() *MockTxBeginnerMockRecorder {
	return m.recorder
}

// BeginTx mocks base method.
func (m *MockTxBeginner) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
	ret0, _ := ret[0].(*sql.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockTxBeginnerMockRecorder) BeginTx(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockTxBeginner)(nil).BeginTx), ctx, opts)
}

// MockWatchedAddressRepository is a mock of WatchedAddressRepository interface.
type MockWatchedAddressRepository struct {
	ctrl     *gomock.Controller
	recorder *MockWatchedAddressRepositoryMockRecorder
	isgomock struct{}
}

// MockWatchedAddressRepositoryMockRecorder is the mock recorder for MockWatchedAddressRepository.
type MockWatchedAddressRepositoryMockRecorder struct {
	mock *MockWatchedAddressRepository
}

// NewMockWatchedAddressRepository creates a new mock instance.
func NewMockWatchedAddressRepository(ctrl *gomock.Controller) *MockWatchedAddressRepository {
	mock := &MockWatchedAddressRepository{ctrl: ctrl}
	mock.recorder = &MockWatchedAddressRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWatchedAddressRepository) EXPECT() *MockWatchedAddressRepositoryMockRecorder {
	return m.recorder
}

// FindByAddress mocks base method.
func (m *MockWatchedAddressRepository) FindByAddress(ctx context.Context, chain model.Chain, network model.Network, address string) (*model.WatchedAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByAddress", ctx, chain, network, address)
	ret0, _ := ret[0].(*model.WatchedAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByAddress indicates an expected call of FindByAddress.
func (mr *MockWatchedAddressRepositoryMockRecorder) FindByAddress(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByAddress", reflect.TypeOf((*MockWatchedAddressRepository)(nil).FindByAddress), ctx, chain, network, address)
}

// GetActive mocks base method.
func (m *MockWatchedAddressRepository) GetActive(ctx context.Context, chain model.Chain, network model.Network) ([]model.WatchedAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetActive", ctx, chain, network)
	ret0, _ := ret[0].([]model.WatchedAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActive indicates an expected call of GetActive.
func (mr *MockWatchedAddressRepositoryMockRecorder) GetActive(ctx, chain, network any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActive", reflect.TypeOf((*MockWatchedAddressRepository)(nil).GetActive), ctx, chain, network)
}

// Upsert mocks base method.
func (m *MockWatchedAddressRepository) Upsert(ctx context.Context, addr *model.WatchedAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, addr)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockWatchedAddressRepositoryMockRecorder) Upsert(ctx, addr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockWatchedAddressRepository)(nil).Upsert), ctx, addr)
}

// MockCursorRepository is a mock of CursorRepository interface.
type MockCursorRepository struct {
	ctrl     *gomock.Controller
	recorder *MockCursorRepositoryMockRecorder
	isgomock struct{}
}

// MockCursorRepositoryMockRecorder is the mock recorder for MockCursorRepository.
type MockCursorRepositoryMockRecorder struct {
	mock *MockCursorRepository
}

// NewMockCursorRepository creates a new mock instance.
func NewMockCursorRepository(ctrl *gomock.Controller) *MockCursorRepository {
	mock := &MockCursorRepository{ctrl: ctrl}
	mock.recorder = &MockCursorRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCursorRepository) EXPECT() *MockCursorRepositoryMockRecorder {
	return m.recorder
}

// EnsureExists mocks base method.
func (m *MockCursorRepository) EnsureExists(ctx context.Context, chain model.Chain, network model.Network, address string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureExists", ctx, chain, network, address)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureExists indicates an expected call of EnsureExists.
func (mr *MockCursorRepositoryMockRecorder) EnsureExists(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureExists", reflect.TypeOf((*MockCursorRepository)(nil).EnsureExists), ctx, chain, network, address)
}

// Get mocks base method.
func (m *MockCursorRepository) Get(ctx context.Context, chain model.Chain, network model.Network, address string) (*model.AddressCursor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, chain, network, address)
	ret0, _ := ret[0].(*model.AddressCursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCursorRepositoryMockRecorder) Get(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCursorRepository)(nil).Get), ctx, chain, network, address)
}

// UpsertTx mocks base method.
func (m *MockCursorRepository) UpsertTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, address string, cursorValue *string, cursorSequence, itemsProcessed int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockCursorRepositoryMockRecorder) UpsertTx(ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockCursorRepository)(nil).UpsertTx), ctx, tx, chain, network, address, cursorValue, cursorSequence, itemsProcessed)
}

// MockTransactionRepository is a mock of TransactionRepository interface.
type MockTransactionRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionRepositoryMockRecorder
	isgomock struct{}
}

// MockTransactionRepositoryMockRecorder is the mock recorder for MockTransactionRepository.
type MockTransactionRepositoryMockRecorder struct {
	mock *MockTransactionRepository
}

// NewMockTransactionRepository creates a new mock instance.
func NewMockTransactionRepository(ctrl *gomock.Controller) *MockTransactionRepository {
	mock := &MockTransactionRepository{ctrl: ctrl}
	mock.recorder = &MockTransactionRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionRepository) EXPECT() *MockTransactionRepositoryMockRecorder {
	return m.recorder
}

// BulkUpsertTx mocks base method.
func (m *MockTransactionRepository) BulkUpsertTx(ctx context.Context, tx *sql.Tx, txns []*model.Transaction) (map[string]uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkUpsertTx", ctx, tx, txns)
	ret0, _ := ret[0].(map[string]uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkUpsertTx indicates an expected call of BulkUpsertTx.
func (mr *MockTransactionRepositoryMockRecorder) BulkUpsertTx(ctx, tx, txns any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkUpsertTx", reflect.TypeOf((*MockTransactionRepository)(nil).BulkUpsertTx), ctx, tx, txns)
}

// UpsertTx mocks base method.
func (m *MockTransactionRepository) UpsertTx(ctx context.Context, tx *sql.Tx, t *model.Transaction) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, t)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockTransactionRepositoryMockRecorder) UpsertTx(ctx, tx, t any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockTransactionRepository)(nil).UpsertTx), ctx, tx, t)
}

// MockBalanceEventRepository is a mock of BalanceEventRepository interface.
type MockBalanceEventRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBalanceEventRepositoryMockRecorder
	isgomock struct{}
}

// MockBalanceEventRepositoryMockRecorder is the mock recorder for MockBalanceEventRepository.
type MockBalanceEventRepositoryMockRecorder struct {
	mock *MockBalanceEventRepository
}

// NewMockBalanceEventRepository creates a new mock instance.
func NewMockBalanceEventRepository(ctrl *gomock.Controller) *MockBalanceEventRepository {
	mock := &MockBalanceEventRepository{ctrl: ctrl}
	mock.recorder = &MockBalanceEventRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceEventRepository) EXPECT() *MockBalanceEventRepositoryMockRecorder {
	return m.recorder
}

// BulkUpsertTx mocks base method.
func (m *MockBalanceEventRepository) BulkUpsertTx(ctx context.Context, tx *sql.Tx, events []*model.BalanceEvent) (store.BulkUpsertEventResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkUpsertTx", ctx, tx, events)
	ret0, _ := ret[0].(store.BulkUpsertEventResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkUpsertTx indicates an expected call of BulkUpsertTx.
func (mr *MockBalanceEventRepositoryMockRecorder) BulkUpsertTx(ctx, tx, events any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkUpsertTx", reflect.TypeOf((*MockBalanceEventRepository)(nil).BulkUpsertTx), ctx, tx, events)
}

// UpsertTx mocks base method.
func (m *MockBalanceEventRepository) UpsertTx(ctx context.Context, tx *sql.Tx, be *model.BalanceEvent) (store.UpsertResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, be)
	ret0, _ := ret[0].(store.UpsertResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockBalanceEventRepositoryMockRecorder) UpsertTx(ctx, tx, be any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockBalanceEventRepository)(nil).UpsertTx), ctx, tx, be)
}

// RecalculateBalanceFieldsTx mocks base method.
func (m *MockBalanceEventRepository) RecalculateBalanceFieldsTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, fromBlock int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RecalculateBalanceFieldsTx", ctx, tx, chain, network, fromBlock)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecalculateBalanceFieldsTx indicates an expected call of RecalculateBalanceFieldsTx.
func (mr *MockBalanceEventRepositoryMockRecorder) RecalculateBalanceFieldsTx(ctx, tx, chain, network, fromBlock any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecalculateBalanceFieldsTx", reflect.TypeOf((*MockBalanceEventRepository)(nil).RecalculateBalanceFieldsTx), ctx, tx, chain, network, fromBlock)
}

// MockBalanceRepository is a mock of BalanceRepository interface.
type MockBalanceRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBalanceRepositoryMockRecorder
	isgomock struct{}
}

// MockBalanceRepositoryMockRecorder is the mock recorder for MockBalanceRepository.
type MockBalanceRepositoryMockRecorder struct {
	mock *MockBalanceRepository
}

// NewMockBalanceRepository creates a new mock instance.
func NewMockBalanceRepository(ctrl *gomock.Controller) *MockBalanceRepository {
	mock := &MockBalanceRepository{ctrl: ctrl}
	mock.recorder = &MockBalanceRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceRepository) EXPECT() *MockBalanceRepositoryMockRecorder {
	return m.recorder
}

// BulkAdjustBalanceTx mocks base method.
func (m *MockBalanceRepository) BulkAdjustBalanceTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, items []store.BulkAdjustItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkAdjustBalanceTx", ctx, tx, chain, network, items)
	ret0, _ := ret[0].(error)
	return ret0
}

// BulkAdjustBalanceTx indicates an expected call of BulkAdjustBalanceTx.
func (mr *MockBalanceRepositoryMockRecorder) BulkAdjustBalanceTx(ctx, tx, chain, network, items any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkAdjustBalanceTx", reflect.TypeOf((*MockBalanceRepository)(nil).BulkAdjustBalanceTx), ctx, tx, chain, network, items)
}

// BulkGetAmountWithExistsTx mocks base method.
func (m *MockBalanceRepository) BulkGetAmountWithExistsTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, keys []store.BalanceKey) (map[store.BalanceKey]store.BalanceInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkGetAmountWithExistsTx", ctx, tx, chain, network, keys)
	ret0, _ := ret[0].(map[store.BalanceKey]store.BalanceInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkGetAmountWithExistsTx indicates an expected call of BulkGetAmountWithExistsTx.
func (mr *MockBalanceRepositoryMockRecorder) BulkGetAmountWithExistsTx(ctx, tx, chain, network, keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkGetAmountWithExistsTx", reflect.TypeOf((*MockBalanceRepository)(nil).BulkGetAmountWithExistsTx), ctx, tx, chain, network, keys)
}

// AdjustBalanceTx mocks base method.
func (m *MockBalanceRepository) AdjustBalanceTx(ctx context.Context, tx *sql.Tx, req store.AdjustRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AdjustBalanceTx", ctx, tx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// AdjustBalanceTx indicates an expected call of AdjustBalanceTx.
func (mr *MockBalanceRepositoryMockRecorder) AdjustBalanceTx(ctx, tx, req any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdjustBalanceTx", reflect.TypeOf((*MockBalanceRepository)(nil).AdjustBalanceTx), ctx, tx, req)
}

// GetAmountTx mocks base method.
func (m *MockBalanceRepository) GetAmountTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, address string, tokenID uuid.UUID, balanceType string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAmountTx", ctx, tx, chain, network, address, tokenID, balanceType)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAmountTx indicates an expected call of GetAmountTx.
func (mr *MockBalanceRepositoryMockRecorder) GetAmountTx(ctx, tx, chain, network, address, tokenID, balanceType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAmountTx", reflect.TypeOf((*MockBalanceRepository)(nil).GetAmountTx), ctx, tx, chain, network, address, tokenID, balanceType)
}

// GetAmountWithExistsTx mocks base method.
func (m *MockBalanceRepository) GetAmountWithExistsTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, address string, tokenID uuid.UUID, balanceType string) (string, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAmountWithExistsTx", ctx, tx, chain, network, address, tokenID, balanceType)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetAmountWithExistsTx indicates an expected call of GetAmountWithExistsTx.
func (mr *MockBalanceRepositoryMockRecorder) GetAmountWithExistsTx(ctx, tx, chain, network, address, tokenID, balanceType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAmountWithExistsTx", reflect.TypeOf((*MockBalanceRepository)(nil).GetAmountWithExistsTx), ctx, tx, chain, network, address, tokenID, balanceType)
}

// GetByAddress mocks base method.
func (m *MockBalanceRepository) GetByAddress(ctx context.Context, chain model.Chain, network model.Network, address string) ([]model.Balance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByAddress", ctx, chain, network, address)
	ret0, _ := ret[0].([]model.Balance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByAddress indicates an expected call of GetByAddress.
func (mr *MockBalanceRepositoryMockRecorder) GetByAddress(ctx, chain, network, address any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByAddress", reflect.TypeOf((*MockBalanceRepository)(nil).GetByAddress), ctx, chain, network, address)
}

// MockTokenRepository is a mock of TokenRepository interface.
type MockTokenRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTokenRepositoryMockRecorder
	isgomock struct{}
}

// MockTokenRepositoryMockRecorder is the mock recorder for MockTokenRepository.
type MockTokenRepositoryMockRecorder struct {
	mock *MockTokenRepository
}

// NewMockTokenRepository creates a new mock instance.
func NewMockTokenRepository(ctrl *gomock.Controller) *MockTokenRepository {
	mock := &MockTokenRepository{ctrl: ctrl}
	mock.recorder = &MockTokenRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenRepository) EXPECT() *MockTokenRepositoryMockRecorder {
	return m.recorder
}

// BulkIsDeniedTx mocks base method.
func (m *MockTokenRepository) BulkIsDeniedTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, contractAddresses []string) (map[string]bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkIsDeniedTx", ctx, tx, chain, network, contractAddresses)
	ret0, _ := ret[0].(map[string]bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkIsDeniedTx indicates an expected call of BulkIsDeniedTx.
func (mr *MockTokenRepositoryMockRecorder) BulkIsDeniedTx(ctx, tx, chain, network, contractAddresses any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkIsDeniedTx", reflect.TypeOf((*MockTokenRepository)(nil).BulkIsDeniedTx), ctx, tx, chain, network, contractAddresses)
}

// BulkUpsertTx mocks base method.
func (m *MockTokenRepository) BulkUpsertTx(ctx context.Context, tx *sql.Tx, tokens []*model.Token) (map[string]uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkUpsertTx", ctx, tx, tokens)
	ret0, _ := ret[0].(map[string]uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkUpsertTx indicates an expected call of BulkUpsertTx.
func (mr *MockTokenRepositoryMockRecorder) BulkUpsertTx(ctx, tx, tokens any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkUpsertTx", reflect.TypeOf((*MockTokenRepository)(nil).BulkUpsertTx), ctx, tx, tokens)
}

// FindByID mocks base method.
func (m *MockTokenRepository) FindByID(ctx context.Context, id uuid.UUID) (*model.Token, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(*model.Token)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockTokenRepositoryMockRecorder) FindByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTokenRepository)(nil).FindByID), ctx, id)
}

// FindByContractAddress mocks base method.
func (m *MockTokenRepository) FindByContractAddress(ctx context.Context, chain model.Chain, network model.Network, contractAddress string) (*model.Token, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByContractAddress", ctx, chain, network, contractAddress)
	ret0, _ := ret[0].(*model.Token)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByContractAddress indicates an expected call of FindByContractAddress.
func (mr *MockTokenRepositoryMockRecorder) FindByContractAddress(ctx, chain, network, contractAddress any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByContractAddress", reflect.TypeOf((*MockTokenRepository)(nil).FindByContractAddress), ctx, chain, network, contractAddress)
}

// IsDeniedTx mocks base method.
func (m *MockTokenRepository) IsDeniedTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, contractAddress string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDeniedTx", ctx, tx, chain, network, contractAddress)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDeniedTx indicates an expected call of IsDeniedTx.
func (mr *MockTokenRepositoryMockRecorder) IsDeniedTx(ctx, tx, chain, network, contractAddress any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDeniedTx", reflect.TypeOf((*MockTokenRepository)(nil).IsDeniedTx), ctx, tx, chain, network, contractAddress)
}

// DenyTokenTx mocks base method.
func (m *MockTokenRepository) DenyTokenTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, contractAddress string, reason string, source string, score int16, signals []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DenyTokenTx", ctx, tx, chain, network, contractAddress, reason, source, score, signals)
	ret0, _ := ret[0].(error)
	return ret0
}

// DenyTokenTx indicates an expected call of DenyTokenTx.
func (mr *MockTokenRepositoryMockRecorder) DenyTokenTx(ctx, tx, chain, network, contractAddress, reason, source, score, signals any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DenyTokenTx", reflect.TypeOf((*MockTokenRepository)(nil).DenyTokenTx), ctx, tx, chain, network, contractAddress, reason, source, score, signals)
}

// AllowTokenTx mocks base method.
func (m *MockTokenRepository) AllowTokenTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, contractAddress string, reason string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllowTokenTx", ctx, tx, chain, network, contractAddress, reason)
	ret0, _ := ret[0].(error)
	return ret0
}

// AllowTokenTx indicates an expected call of AllowTokenTx.
func (mr *MockTokenRepositoryMockRecorder) AllowTokenTx(ctx, tx, chain, network, contractAddress, reason any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllowTokenTx", reflect.TypeOf((*MockTokenRepository)(nil).AllowTokenTx), ctx, tx, chain, network, contractAddress, reason)
}

// UpsertTx mocks base method.
func (m *MockTokenRepository) UpsertTx(ctx context.Context, tx *sql.Tx, t *model.Token) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTx", ctx, tx, t)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTx indicates an expected call of UpsertTx.
func (mr *MockTokenRepositoryMockRecorder) UpsertTx(ctx, tx, t any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTx", reflect.TypeOf((*MockTokenRepository)(nil).UpsertTx), ctx, tx, t)
}

// MockIndexerConfigRepository is a mock of IndexerConfigRepository interface.
type MockIndexerConfigRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIndexerConfigRepositoryMockRecorder
	isgomock struct{}
}

// MockIndexerConfigRepositoryMockRecorder is the mock recorder for MockIndexerConfigRepository.
type MockIndexerConfigRepositoryMockRecorder struct {
	mock *MockIndexerConfigRepository
}

// NewMockIndexerConfigRepository creates a new mock instance.
func NewMockIndexerConfigRepository(ctrl *gomock.Controller) *MockIndexerConfigRepository {
	mock := &MockIndexerConfigRepository{ctrl: ctrl}
	mock.recorder = &MockIndexerConfigRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexerConfigRepository) EXPECT() *MockIndexerConfigRepositoryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockIndexerConfigRepository) Get(ctx context.Context, chain model.Chain, network model.Network) (*model.IndexerConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, chain, network)
	ret0, _ := ret[0].(*model.IndexerConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockIndexerConfigRepositoryMockRecorder) Get(ctx, chain, network any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIndexerConfigRepository)(nil).Get), ctx, chain, network)
}

// UpdateWatermarkTx mocks base method.
func (m *MockIndexerConfigRepository) UpdateWatermarkTx(ctx context.Context, tx *sql.Tx, chain model.Chain, network model.Network, ingestedSequence int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWatermarkTx", ctx, tx, chain, network, ingestedSequence)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWatermarkTx indicates an expected call of UpdateWatermarkTx.
func (mr *MockIndexerConfigRepositoryMockRecorder) UpdateWatermarkTx(ctx, tx, chain, network, ingestedSequence any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWatermarkTx", reflect.TypeOf((*MockIndexerConfigRepository)(nil).UpdateWatermarkTx), ctx, tx, chain, network, ingestedSequence)
}

// GetWatermark mocks base method.
func (m *MockIndexerConfigRepository) GetWatermark(ctx context.Context, chain model.Chain, network model.Network) (*model.PipelineWatermark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWatermark", ctx, chain, network)
	ret0, _ := ret[0].(*model.PipelineWatermark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWatermark indicates an expected call of GetWatermark.
func (mr *MockIndexerConfigRepositoryMockRecorder) GetWatermark(ctx, chain, network any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWatermark", reflect.TypeOf((*MockIndexerConfigRepository)(nil).GetWatermark), ctx, chain, network)
}

// Upsert mocks base method.
func (m *MockIndexerConfigRepository) Upsert(ctx context.Context, c *model.IndexerConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, c)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockIndexerConfigRepositoryMockRecorder) Upsert(ctx, c any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockIndexerConfigRepository)(nil).Upsert), ctx, c)
}
